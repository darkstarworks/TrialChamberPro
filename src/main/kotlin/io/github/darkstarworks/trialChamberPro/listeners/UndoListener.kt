package io.github.darkstarworks.trialChamberPro.listeners

import io.github.darkstarworks.trialChamberPro.TrialChamberPro
import io.github.darkstarworks.trialChamberPro.utils.UndoTracker
import io.papermc.paper.event.player.AsyncChatEvent
import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer
import org.bukkit.event.EventHandler
import org.bukkit.event.EventPriority
import org.bukkit.event.Listener
import org.bukkit.event.player.PlayerCommandPreprocessEvent

class UndoListener(private val plugin: TrialChamberPro) : Listener {
    private val confirmWindowSeconds = 15

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    fun onCommandPreprocess(event: PlayerCommandPreprocessEvent) {
        val msg = event.message.trim().lowercase()
        if (msg == "/undo" || msg.startsWith("//undo")) {
            val player = event.player
            val last = UndoTracker.getLast(player.uniqueId)
            val pending = UndoTracker.getPending(player.uniqueId)
            if (last != null) {
                // Intercept and require confirmation
                event.isCancelled = true
                if (pending == null) {
                    UndoTracker.setPending(player.uniqueId, last.chamberName, confirmWindowSeconds)
                    player.sendMessage(plugin.getMessage("undo-confirm",
                        "chamber" to last.chamberName,
                        "seconds" to confirmWindowSeconds
                    ))
                } else {
                    player.sendMessage(plugin.getMessage("undo-confirm-pending",
                        "chamber" to pending.chamberName,
                        "seconds" to ((pending.expiresAt - System.currentTimeMillis()) / 1000).coerceAtLeast(0)
                    ))
                }
            } else {
                // No last generated by plugin; let WorldEdit handle its own //undo
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    fun onAsyncChat(event: AsyncChatEvent) {
        val player = event.player
        val pending = UndoTracker.getPending(player.uniqueId) ?: return
        // Extract plain text from Adventure component
        val content = PlainTextComponentSerializer.plainText().serialize(event.message()).trim().lowercase()

        when (content) {
            "confirm" -> {
                event.isCancelled = true
                UndoTracker.clearPending(player.uniqueId)
                // Perform deletion asynchronously via coroutine (no runBlocking)
                plugin.launchAsync {
                    val success = try {
                        plugin.chamberManager.deleteChamber(pending.chamberName)
                    } catch (e: Exception) {
                        plugin.logger.warning("Failed to delete chamber: ${e.message}")
                        false
                    }
                    plugin.scheduler.runAtEntity(player, Runnable {
                        if (player.isOnline) {
                            if (success) {
                                player.sendMessage(plugin.getMessage("undo-deleted", "chamber" to pending.chamberName))
                                UndoTracker.clearLast(player.uniqueId)
                            } else {
                                player.sendMessage(plugin.getMessage("undo-failed", "chamber" to pending.chamberName))
                            }
                        }
                    })
                }
            }
            "cancel" -> {
                event.isCancelled = true
                UndoTracker.clearPending(player.uniqueId)
                player.sendMessage(plugin.getMessage("undo-cancelled"))
            }
            else -> {
                // If expired meanwhile, inform player
                if (System.currentTimeMillis() > pending.expiresAt) {
                    UndoTracker.clearPending(player.uniqueId)
                    player.sendMessage(plugin.getMessage("undo-expired"))
                }
            }
        }
    }
}
