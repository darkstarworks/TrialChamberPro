package io.github.darkstarworks.trialChamberPro.listeners

import io.github.darkstarworks.trialChamberPro.TrialChamberPro
import io.github.darkstarworks.trialChamberPro.utils.UndoTracker
import org.bukkit.Bukkit
import org.bukkit.event.EventHandler
import org.bukkit.event.EventPriority
import org.bukkit.event.Listener
import org.bukkit.event.player.AsyncPlayerChatEvent
import org.bukkit.event.player.PlayerCommandPreprocessEvent

class UndoListener(private val plugin: TrialChamberPro) : Listener {
    private val confirmWindowSeconds = 15

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    fun onCommandPreprocess(event: PlayerCommandPreprocessEvent) {
        val msg = event.message.trim().lowercase()
        if (msg == "/undo" || msg.startsWith("//undo")) {
            val player = event.player
            val last = UndoTracker.getLast(player.uniqueId)
            val pending = UndoTracker.getPending(player.uniqueId)
            if (last != null) {
                // Intercept and require confirmation
                event.isCancelled = true
                if (pending == null) {
                    UndoTracker.setPending(player.uniqueId, last.chamberName, confirmWindowSeconds)
                    player.sendMessage(plugin.getMessage("undo-confirm",
                        "chamber" to last.chamberName,
                        "seconds" to confirmWindowSeconds
                    ))
                } else {
                    player.sendMessage(plugin.getMessage("undo-confirm-pending",
                        "chamber" to pending.chamberName,
                        "seconds" to ((pending.expiresAt - System.currentTimeMillis()) / 1000).coerceAtLeast(0)
                    ))
                }
            } else {
                // No last generated by plugin; let WorldEdit handle its own //undo
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    fun onAsyncChat(event: AsyncPlayerChatEvent) {
        val player = event.player
        val pending = UndoTracker.getPending(player.uniqueId) ?: return
        val content = event.message.trim().lowercase()

        when (content) {
            "confirm" -> {
                event.isCancelled = true
                UndoTracker.clearPending(player.uniqueId)
                // Perform deletion asynchronously, then message on main thread
                Bukkit.getScheduler().runTaskAsynchronously(plugin, Runnable {
                    val success = try {
                        // suspend function; call via runBlocking? We'll use blocking bridge
                        kotlinx.coroutines.runBlocking {
                            plugin.chamberManager.deleteChamber(pending.chamberName)
                        }
                    } catch (_: Exception) {
                        false
                    }
                    Bukkit.getScheduler().runTask(plugin, Runnable {
                        if (success) {
                            player.sendMessage(plugin.getMessage("undo-deleted", "chamber" to pending.chamberName))
                            UndoTracker.clearLast(player.uniqueId)
                        } else {
                            player.sendMessage(plugin.getMessage("undo-failed", "chamber" to pending.chamberName))
                        }
                    })
                })
            }
            "cancel" -> {
                event.isCancelled = true
                UndoTracker.clearPending(player.uniqueId)
                player.sendMessage(plugin.getMessage("undo-cancelled"))
            }
            else -> {
                // If expired meanwhile, inform player
                if (System.currentTimeMillis() > pending.expiresAt) {
                    UndoTracker.clearPending(player.uniqueId)
                    player.sendMessage(plugin.getMessage("undo-expired"))
                }
            }
        }
    }
}
